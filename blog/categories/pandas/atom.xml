<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: pandas | linpingta's blog]]></title>
  <link href="http://yoursite.com/blog/categories/pandas/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2020-06-24T10:13:34+08:00</updated>
  <id>http://yoursite.com/</id>
  <author>
    <name><![CDATA[linpingta]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[kaggle-shelter-animal-outcome]]></title>
    <link href="http://yoursite.com/blog/2016/07/10/kaggle-shelter-animal-outcome/"/>
    <updated>2016-07-10T15:31:14+08:00</updated>
    <id>http://yoursite.com/blog/2016/07/10/kaggle-shelter-animal-outcome</id>
    <content type="html"><![CDATA[<p>这是一篇关于<a href="https://www.kaggle.com/c/shelter-animal-outcomes">Kaggle:Shelter Animal Outcomes</a>比赛的总结。</p>

<h3>比赛<a href="https://www.kaggle.com/c/shelter-animal-outcomes">背景</a></h3>

<p>比赛是基于美国一个州过去三年宠物收容所对宠物的记录数据，去预测宠物的最终命运。它本身是一个预测问题，用到的自变量包括官方提供的以下特征：</p>

<pre><code>AnimalID,Name,DateTime,OutcomeType,OutcomeSubtype,AnimalType,SexuponOutcome,AgeuponOutcome,Breed,Color
</code></pre>

<p>去预测宠物的最终命运，可能的选项包括：</p>

<pre><code>Adoption，Died，Euthanasia，Return_to_owner, Transfer
</code></pre>

<p>用到的最终评价标准是<a href="https://www.kaggle.com/c/shelter-animal-outcomes/details/evaluation">multiclass logloss</a>，简单来说就是它需要输出每个测试样本属于每类的可能性，而不是最有可能的类别，同时会更大的惩罚那些肯定性判断 （把每个记录以100%的输出错分会受到很大的惩罚），实际上最终leaderboard中那些误差大于3的提交结果应该都是输出了错误的判决结果。</p>

<h3>比赛结果</h3>

<p>截止本文完成时，我的排名是 54th/1289，比赛还有20天结束，但我已不打算进一步优化结果，最终结果应该会在结束后有所变化，我会在相应时间更新。</p>

<h3>最终方案</h3>

<h4>特征选择和处理</h4>

<p>我最终使用的特征包括：</p>

<ul>
<li>时间特征：DateTime部分被处理为5个部分

<ul>
<li> YEAR/MONTH/WEEKDAY/HOUR/UNIXTIME</li>
</ul>
</li>
<li>年龄特征：原始的年龄特征包含如“3 months”, &ldquo;2 weeks"等，全部转换为天为单位的表示，原始数据中部分动物没有年龄，相应数据被转为0（也看到过一些根据其它信息去预测年龄做填充的方案，没有尝试）</li>
<li>名称特征：原始名称转为是否有名称，名称的长度两个新特征</li>
<li>性别特征：原始性别实际包含Male/Female以及是否被阉割Intact的信息，转为Male/Female和Intact/Not Intact两个新特征</li>
<li>品种特征：首先把训练集和测试集的所有品种做统计，因为记录中每个动物都可能属于多个品种，因此把属于某品种记为1，不属于记为0</li>
<li>颜色特征：处理方法类似品种，和品种的区别是，品种会把是否包含Mix和/作为分隔符，颜色会把空格作为分隔符</li>
<li>去除处理过的原始特征，以及Animal ID信息，对测试集编码后（scikit-learn fit_transform），采用相同的编码方式处理训练集</li>
</ul>


<h4>模型选择</h4>

<p>最终我使用的是由ChenTianqi（中国人，非常厉害）开发的<a href="https://github.com/dmlc/xgboost">XGBoost</a>作为学习模型，如XGBoost名称所示，它本身就是一种boosting方法，在我的测试中，它的效果要比RandomForest更好。</p>

<p>最终的参数：</p>

<pre><code>param = {'max_depth':11, 'eta':0.03, 'subsample':0.75, 'colsample_bytree':0.85, 'eval_metric':'mlogloss', 'objective':'multi:softprob', 'num_class':5, 'verbose':1}
num_round = 400
dtrain = xgb.DMatrix(train_x, label=train_y)
clf = xgb.train(param, dtrain, num_round)
</code></pre>

<p>关于XGBoost的介绍，首先参考它的<a href="https://github.com/dmlc/xgboost/tree/master/python-package">Github</a>（包含使用的Example），其次关于参数调优可以参考<a href="http://www.analyticsvidhya.com/blog/2016/03/complete-guide-parameter-tuning-xgboost-with-codes-python/">这篇文章</a></p>

<p>PS. XGBoost本身是基于C开发的，它提供了R和Python两种接口，就我看到的情况看，R语言的接口相比Python会更方便一些，如果将来有机会，我还会对XGBoost做更多的探索。</p>

<h3>我做过的尝试</h3>

<p>我相信最终的方案并不是这次比赛的全部收获（或者更直白的说，只是很少一部分），作为第一个真正认真参加的Kaggle比赛，我想记录一个Kaggle新手在处理问题的过程，对阅读博客的人有更多帮助。</p>

<p>下面的尝试我大致按时间记录：
1. 第一次：几乎没有处理原始数据，只是去除无用的字段（比如OutcomeSubtype, AnimalID）用RandomForest直接训练，得到的logloss是13.8：这里的问题在于，没有看清题目的损失评价方法是logloss，直接用的分类树而不是回归树，给出一堆0，1结果
2. 第二次：仅仅是更新损失评价方法和树类别，logloss下降到3.4
3. 第三次：开始真正意义上的数据清理，包括如下尝试：</p>

<pre><code>* 处理Age信息，把年月日数据统一为天表示
* 尝试把猫和狗作为独立的对象分别训练
* 处理Datetime，转为年月，weekday以及几点钟
* 添加本地的cross validation
这个阶段结束后，logloss下降到1.8
</code></pre>

<p>4.第四次：回归模型参数，发现在RandomForest中使用的树数量和树深度都太少太浅，调整参数，logloss下降到0.98
5.第五次：增加名称信息，增加Sex分隔处理，处理品种和颜色是否混合的信息
6.第六次：开始使用Grid Search做参数空间的搜索，经过参数优化后，logloss大概在0.82左右
7.第七次：用XGBoost替换RandomForest，调整相关参数，之后又对年龄特征做了细化，logloss达到0.75左右
8.这之后其实有一段很长的时间，logloss并没有什么提高，这期间我尝试过用KNN（没有太多调优，误差在0.98），尝试过<a href="http://linpingta.cn/blog/2016/06/25/model-stacking/#disqus_thread">模型融合</a>，还尝试过使用场外特征，但是都没有在logloss上面有明显的改善（场外还是有一些改善，但并不合法还是放弃了）
9.最后的改进：在特征中加入UnixDateTime特征，以及把XGBoost算法从scikit-learn版本更改为它的原生版本，logloss达到0.72，再更新参数和训练周期(num_round)，最佳logloss达到0.708。</p>

<h3>项目代码</h3>

<p><a href="https://github.com/linpingta/shelter-animal-outcome">Github地址</a></p>

<h3>经验和教训</h3>

<p>大致来说，logloss的改进经过“特征处理->模型调参->特征处理”这样不断循环的过程，在模型大致可行的前提下，特征工程，指的是发现新特征，或者处理原有特征，会对结果又明显的改善，但是这句话的前提是模型大致可行，也就是说模型本身的参数，以及选择哪个模型，仍然是非常重要的。
结论性的来说，模型和特征是解决问题的两个重要因素，哪个弄不动了就试试另外一个，通常会不断提升结果。
这次也对模型融合做了一些尝试，效果不是很好，但相信以后会有更好的结果。</p>

<h3>关于Kaggle</h3>

<p>其实关于kaggle有没有用，网上有很多说法，但主要的说法是，你要指望通过kaggle去做data science，是不太靠谱的。因为它的数据集本身是比较干净的（虽然也有缺省值要处理），问题的目标也是比较清晰的（损失函数都告诉你了嘛），而实际工作中，包括我自己遇到的问题里，如何去定义问题，去处理数据，往往是问题中最困难的（其实定义问题是最困难的，很多问题并没有那么明显的损失函数去描述）。
我觉得这种说法是很有道理的，所以我想说kaggle的比赛结果并不能说明什么，但为什么我还愿意参加这样的比赛，我想是基于以下的理由：</p>

<pre><code>1. 接触那些与工作内容完全不同的问题：Kaggle上有各类机器学习的问题，分类回归聚类，图像NLP，一个人的实际工作中其实很难接触到太多方面，这里是个好途径
2. 学习新的模型，新的方法：恰恰是因为不用去做数据提取和预处理的工作，可以让人更专注于模型本身。我可以学习到新的模型，新的调参方法，这些或许在将来会给予工作帮助
3. 它本身有一定的意义。Kaggle比赛不能排除作弊，但它毕竟是一个很明确的问题。从我不长时间的面试和被面试经验看，机器学习相关的项目经验，由于业务本身特点（内部工具或者多人合作），其实是很难在面试很短时间内描述清楚的。Kaggle的比赛至少可以说明一个人在运用模型方面的基本能力是get了，因为Kaggle的比赛是一定包括训练集测试集特征处理交叉验证这些基础的方法的。我不认为Kaggle的优胜者一定是一个好的data engineer，但至少说明他在数据这个大领域的某些方面还不错。
</code></pre>

<p>最后说一点，除了以上的经验，我根据一般模型训练的步骤开发了一套<a href="https://github.com/linpingta/tools/tree/master/model_trainer">框架</a>，可以方便以后使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pandas 数据准备篇]]></title>
    <link href="http://yoursite.com/blog/2014/05/13/pandas-data-input/"/>
    <updated>2014-05-13T23:20:55+08:00</updated>
    <id>http://yoursite.com/blog/2014/05/13/pandas-data-input</id>
    <content type="html"><![CDATA[<p>从csv或者文本文件读取数据</p>

<pre><code> import pandas as pd

 r = pd.read_csv('example.csv') # 读取csv文件，默认第一行是header column
 r = pd.read_csv('example.csv', header=None) # 读取csv，第一行也是数据
 r = pd.read_table('example.csv', seperator=',') # 读取文件，按逗号分隔

 pd.isnull(r) # return True 对于NaN，-1.#IND和NULL的位置，其它return False
 因此可以用来区分数据有效性
 也可以通过调用时指定na_values来定义对用户的无效数据

 pd.read_csv('example.csv', na_values=['NULL'])

 na_values 可以进一步扩展为每列不同
 na_values = {'column1':['NA'],'column2':['NULL']}

 #读取部分文件 (前N行数据)
 pd.read_csv('example.csv',nrows=N)

 #将DataFrame中的数据输出到csv
 DataFrame.to_csv('output.csv')

 pd.date_range(start,end,period) # pandas data_range 指定了起始日期，结束日期或者持续长度
</code></pre>

<p>从数据库里导入数据</p>

<pre><code> import MySQLdb
 import pandas.io.sql as sql

 #conn 用于建立数据连接
 sql.read_frame('select * from your_table', conn)
</code></pre>

<p>例如:</p>

<pre><code> conn = MySQLdb.connect(host='localhost',user='root',passwd='pass',db='tablename',port=3306,charset='utf8')
 r = sql.read_frame('select * from dw_year', conn)

 &gt;&gt;&gt;
 YEAR_ID  YEAR  PRE_YEAR_ID
0        1  2010          NaN
1        2  2011            1
2        3  2012            2
3        4  2013            3
4        5  2014            4
5        6  2015            5
</code></pre>

<p>数据连接
pandas.merge: 将DateFrames按照一定的key进行连接</p>

<p>pandas将dict转为DataFrame: key作为column，value作为每行元素（通常是list）</p>

<pre><code> df1 = DataFrame({'key1': range(2), 'key2':range(2)})
</code></pre>

<p>pandas.merge(df1,df2) 默认按照df1和df2中公有名称的key进行merge
     或者显式调用</p>

<pre><code> pandas.merge(df1,df2,on='keyname')
</code></pre>

<p>如果在df1和df2中key名称并不相同，那么可以指定merge的left key和right key</p>

<pre><code> pandas.merge(df1,df2,left_on='lkey',right_on='rkey')
</code></pre>

<p>可以通过how来指定join是left join, right join还是outer join</p>

<pre><code> pd.merge(df1, df2, how='outer')
</code></pre>

<p>看起来merge并没有复杂的操作，实际上是把sql的join操作在DataFrame level上重新进行了一次实现</p>

<p>merge on index : 如果在定义DataFrame的时候用到了index （比如DataFrame({}, index=[&lsquo;a&rsquo;,&lsquo;b&rsquo;])）那么可以通过left_index=True或者right_index=True来指定使用index而非后面的column进行匹配（实际上这里的index是一个特殊的column）</p>
]]></content>
  </entry>
  
</feed>
